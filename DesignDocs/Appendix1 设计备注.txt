1. 对常量的处理：
在C++中，实际存在两种常量，一种是编译时就可确定其值的，往往是用常量表达式初始化的const修饰的变量。
另一种常量是也用const修饰，但却用非常量表达式初始化的变量，这样的常量属于常变量。

在PL/0语言中，定义的常量均属于第一种常量。
故程序在处理时，在四元式生成过程中，就将常量替换成为常数，而不用特定的常变量来对其进行特别的分类处理。

2. 由于对常量的处理方式，故case语句可将情况表元素扩展为常数与常量。但暂不准备扩展为常量表达式。

3. 扩展continue和break
在语法分析时，时刻维护着一个continue和break的跳转标号栈
遇到continue或break时，就跳到栈顶
若栈为空，说明无法跳转，报错

4. 赋值优化
赋值语句中，若被赋值元素非数组，且赋值号右边的表达式的属性是临时变量，则可以优化掉赋值语句的四元式，直接将被赋值元素的属性写到表达式中最后一条语句的dst中即可

5. 类型转换
设计了VOID CHAR INTEGER的类型转换规则与类型转换矩阵

6. 汇编中的call和ret
如果自己用jmp语句代替call和ret的话，会对运行栈有较好的理解
如果使用汇编中的call和ret的话，编写汇编过程会方便些
由于汇编指令中不允许操作EIP寄存器，故只能用call和ret实现函数的调用和返回【注：函数调用可以用jmp代替，但无法存储返回地址】

7. 函数返回值的存储
在正常处理流程中，希望将函数的返回值放置在temp#tempvar_index的位置，这样比较贴合之前的设计框架。否则还要有专门处理函数返回值的操作数属性（因其取址方式比较特殊）
但在子函数中，无法判定temp#tempvar_index的位置。如果放在活动记录块的起始位置的话，这块内存在调用者的栈中的相对位置是不确定的，需要由ESP的具体控制方式来决定，而且无论ESP如何控制，在实现的时候都很麻烦，要处理特殊情况（譬如，不断调整栈顶指针ESP，或临时变量的使用编号不连续造成逻辑错误）。
所以子函数将返回值存储在EAX中，再加一条指令，将EAX的值存进临时变量中。
注：存储EBX至临时变量的语句，可能会被赋值语句优化掉，直接存储至普通变量中。

8. 运行栈中栈指针ESP的控制
运行栈中，局部变量的数量是固定的，这里不会变动。但由于临时变量有申请，有释放，所以实际的栈顶是会变的。
但如果每次都随着临时变量的申请和释放来调整栈顶指针的话，又太过麻烦，效率太低。
所以，在生成中间代码时，记录好每个过程/函数中用到的临时变量的数量，在初始化活动记录块时，用SP预留出足够的空间来，就不需要变来变去了。

9. 临时变量使用的最大数量计算
并没有准确地计算出每个函数用到的临时变量的数量
因为在赋值语句进行优化时，不能确定优化掉的临时变量在之前是否发挥过必要的作用
所以计算出的数量是最大值，也是没有赋值语句优化时的临时变量数量