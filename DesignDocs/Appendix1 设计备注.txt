1. 对常量的处理：
在C++中，实际存在两种常量，一种是编译时就可确定其值的，往往是用常量表达式初始化的const修饰的变量。
另一种常量是也用const修饰，但却用非常量表达式初始化的变量，这样的常量属于常变量。

在PL/0语言中，定义的常量均属于第一种常量。
故程序在处理时，在四元式生成过程中，就将常量替换成为常数，而不用特定的常变量来对其进行特别的分类处理。

2. 由于对常量的处理方式，故case语句可将情况表元素扩展为常数与常量。但暂不准备扩展为常量表达式。

3. 扩展continue和break
在语法分析时，时刻维护着一个continue和break的跳转标号栈
遇到continue或break时，就跳到栈顶
若栈为空，说明无法跳转，报错

4. 赋值优化
赋值语句中，若被赋值元素非数组，且赋值号右边的表达式的属性是临时变量，则可以优化掉赋值语句的四元式，直接将被赋值元素的属性写到表达式中最后一条语句的dst中即可

5. 类型转换
设计了VOID CHAR INTEGER的类型转换规则与类型转换矩阵

6. 汇编中的call和ret
如果自己用jmp语句代替call和ret的话，会对运行栈有较好的理解，且函数的返回值的传递要容易些（紧挨着上一个函数的运行栈空间）
如果使用汇编中的call和ret的话，编写汇编过程会方便些，但函数返回值的传递在中间代码生成中，要多出一种操作数的类型来
为了更好地理解运行栈，且和中间代码生成中的逻辑相容，故采用自己实现call和ret的方式

