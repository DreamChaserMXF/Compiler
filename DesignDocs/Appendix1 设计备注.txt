1. 对常量的处理：
在C++中，实际存在两种常量，一种是编译时就可确定其值的，往往是用常量表达式初始化的const修饰的变量。
另一种常量是也用const修饰，但却用非常量表达式初始化的变量，这样的常量属于常变量。

在PL/0语言中，定义的常量均属于第一种常量。
故程序在处理时，在四元式生成过程中，就将常量替换成为常数，而不用特定的常变量来对其进行特别的分类处理。
因此，常量继续占据存储空间也没什么意义了，所以在符号表中，令所有的常量的地址为零，不占据存储空间。

2. 由于对常量的处理方式，故case语句可将情况表元素扩展为常数与常量。但暂不准备扩展为常量表达式。

3. 扩展continue和break
在语法分析时，时刻维护着一个continue和break的跳转标号栈
遇到continue或break时，就跳到栈顶
若栈为空，说明无法跳转，报错

4. 赋值优化
赋值语句中，若被赋值元素非数组，且赋值号右边的表达式的属性是临时变量，则可以优化掉赋值语句的四元式，直接将被赋值元素的属性写到表达式中最后一条语句的dst中即可

/*但有一项情况特殊，因为NEG的四元式的效果最初是这样设计的：dst[offset] = -dst[offset]，这样，当dst是临时变量时，如果NEG被赋值语句优化掉，那么NEG的语义中的源操作数也将失效。
有两种选择：第一种是更改NEG的语义为 dst = - src1，此时将源操作数与目的操作数分开，便不会影响赋值语句的优化。
第二种选择，是在赋值语句处判定，如果上一条语句是NEG，便不予优化。

首先考虑的一点：如果用第一种选择，便丢失了数组操作数。那么，可以验证一下，在汇编语言中，NEG的操作数可否为内存地址。如果可以的话，第一种选择确实是一种损失。因为对数组元素的取反，本来一条NEG的汇编指令就可完成，现在需要将数组元素赋值给临时变量，再取反，再赋值回自己。
第二种选择问题在于，这样的NEG的语义形式与其他四元式的就不统一了，不知道在做编译优化的时候是否会有影响。

验证NEG的操作数：可以为内存地址。
故暂采用第二种方法，在赋值语句优化处进行判定，对NEG进行特殊处理。
若到了编译优化时，发现NEG语句的语义不统一造成了更大的问题，再作斟酌。
*/

卧槽，NEG的语义写错了，还没遇到赋值号，怎么能产生副作用呢？！
重写NEG四元式！


5. 类型转换
设计了VOID CHAR INTEGER的类型转换规则与类型转换矩阵

6. 汇编中的call和ret
如果自己用jmp语句代替call和ret的话，会对运行栈有较好的理解
如果使用汇编中的call和ret的话，编写汇编过程会方便些
由于汇编指令中不允许操作EIP寄存器，故只能用call和ret实现函数的调用和返回【注：函数调用可以用jmp代替，但无法存储返回地址】

7. 函数返回值的存储
在正常处理流程中，希望将函数的返回值放置在temp#tempvar_index的位置，这样比较贴合之前的设计框架。否则还要有专门处理函数返回值的操作数属性（因其取址方式比较特殊）
但在子函数中，无法判定temp#tempvar_index的位置。如果放在活动记录块的起始位置的话，这块内存在调用者的栈中的相对位置是不确定的，需要由ESP的具体控制方式来决定，而且无论ESP如何控制，在实现的时候都很麻烦，要处理特殊情况，在设计时与运行栈的结构紧密相关。
所以子函数将返回值存储在EAX中，再加一条指令，将EAX的值存进临时变量中。
注：存储EAX至临时变量的语句，可能会被赋值语句优化掉，直接存储至普通变量中。

8. 运行栈中栈指针ESP的控制
运行栈中，局部变量的数量是固定的，这里不会变动。但由于临时变量有申请，有释放，所以实际的栈顶是会变的。
但如果每次都随着临时变量的申请和释放来调整栈顶指针的话，又太过麻烦，效率太低。
所以，在生成中间代码时，记录好每个过程/函数中用到的临时变量的数量，在初始化活动记录块时，用SP预留出足够的空间来，就不需要变来变去了。

9. 临时变量使用的最大数量计算
在中间代码生成时，手动为主函数生成BEGIN和END
然后扫描一遍中间代码，对每个BEGIN语句所代表的函数，找到最大的临时变量使用数，更新到BEGIN语句中

10. 过程调用与函数调用
在最后的实现中，两者的调用方式都是相同的。这是因为将函数的返回值的存储位置定为了EAX中。
如果将返回值放在运行栈中的话，那么函数调用就要比过程调用多预留出一个返回值的存储位置。
但由于最开始的设定中，两者的调用方式不同，故出现了两种四元式的操作码，FUNC_CALL与PROC_CALL。
在最后的实现中，两者翻译成的汇编码是相同的。

11. write函数调用时的类型推导
在实现时，困难之处在于，编译到中间代码四元式时，四元式的信息中，只有一个操作符和三个操作数。操作数有两个属性，取址方式属性和值属性。但却没有类型属性。
在最终转换成汇编码的时候，是通过四元式和符号表来转换的。而如果四元式的操作数是立即数或临时变量，那么，它们的类型是什么呢？
没错，是可以在四元式中的取址方式中，将立即数改成整型立即数和字符型立即数，将临时变量也赋予类型，甚至将临时变量存储在符号表中。但这样子，就破坏了取址方式本来的意义，造成了划分的不统一（本来是每种取址方式对应一个枚举类型，但现在一种立即数的取址方式就对应了两个枚举类型）。
所以，为了照顾write的类型推断，这里就只好把四元式的目的操作数再加一个类型属性，在write语句的语法分析过程中，对要写的表达式记录其修饰类型。

12. EBP的位置设定
在最开始时，本来想将EBP设置在display区的开始位置，即[EBP-4]为display区的第一个元素。
但这样的话，在函数调用之前，就要设置EBP。但调用前要赋值display区和参数，也要用到EBP。所以只能在display区处理完成、参数压栈滞后，call语句之前设置EBP。
但此时需要保存EBP的值，在函数调用完成后再自行恢复。因为有函数参数在栈中，故不能用栈的PUSH POP来保存EBP。否则就要修改运行栈的结构。
且在翻译到call语句时，EBP的位置设定还需计算。
故采用通用的方法，在被调用的函数的首部将EBP压栈并设置EBP，返回时将EBP出栈即可。这样，调用者不必考虑EBP的改变，在call完之后，只需修改栈顶指针，便可恢复现场。

13. 临时变量的编号方式
之前的临时变量的编号都是从0开始，这样会给寻址带来很大不便。
本想更改为，临时变量与局部变量统一编址。在subroutine中的变量说明部分完成后，便可确定临时变量的个数。
然而，这样会导致之后很难准确计算一个函数中使用的临时变量个数。
但如果统一编址的话，就不需要单独计算临时变量个数了，而需计算局部变量和临时变量的总数【因为计算临时变量的个数是用来调整栈顶指针的，而栈顶指针的调整需要局部变量和临时变量所占的空间之和】
但计算局部变量和临时变量的总数的话，太麻烦了。
所以还是令临时变量的编号从0开始好了。

另：普通变量和临时变量在寻址时确实方式有差异（普通变量可能是外层变量，临时变量只会是局部变量）

14. 四元式生成时，对两个常数的运算的优化->直接在编译时计算结果

15. 符号表中的层次问题
符号表中，隐含的主函数是第0层，主函数中定义的变量和过程/函数是第1层。
这样，函数的层次便可和display区的长度统一起来。
在符号表生成时，level的初值是1。因为主函数名不出现在符号表中，所以level的初值不需要为0。

16. 名词释义：普通变量：即程序中定义的，非数组的变量，包括各个函数定义的局部变量与参数。与数组变量、临时变量共同构成整个程序的变量空间。

17. 编码格式：要求输入文件以ANSI格式编码，否则将无法正常输出中文
 
18. 转义字符的处理：
在读取字符串或字符常量时，要求在词法分析时就读出转义字符的内容。这里用switch替换来进行操作。
注：后来改为用数组来处理。
在将字符串写到数据段中，有的字符串太长了，所以要分行写，每行后面不能有逗号
注：经测试得出，每行的整数不能超过49个，字符不能超过251个（不算双引号）。（据测试，应该是这样算的：一个连续（用单引号扩住的）的字符序列不能超过251个字符，用逗号隔开的对象的个数不能超过49个）
很奇怪的是，用-255到255闭区间的任何数初始化db的数据段都是允许的。真的不知道这个汇编程序怎样用-255去初始化一个byte

19. 对外部变量的引用时，不能用已有的EBP作为基指针。则采用何种策略？
策略1：分支，分成两种情况，对局部变量，或对外部变量
策略2：判断，若外部变量，则保存EBP，再更新EBP，然后将变量视作局部变量执行指令。最后再判断，若是外部变量，则再恢复EBP的值。
理论上，对一般的变量，这两种策略都可以。
但对数组变量来说，若更新了EBP，那么，在取数组的下标元素的变量的值时，便使用了错误的EBP，导致程序崩溃。
所以一律采用策略1。

20. 寄存器约定：
EAX, EDX用作计算，EBP用作基指针，EBX用作计算外层的EBP。ECX用作计算数组下标的偏移量的寄存器。

21. 内存地址前的类型修饰符（dword ptr）
当操作数有两个，且另一个是寄存器时，不需要加类型修饰符。但另一个是立即数时，要加类型修饰符。

当操作数只有一个时，NEG和IMUL, IDIV需要加，PUSH不需要（每次都是4字节）。

综上，在另一个是寄存器的情况下，不加dword ptr 修饰，其余情况均添加dword ptr 修饰。

22. 引用类型的实现
因为最后才发现了有引用传参的功能，所以之前没有考虑进去。
故，对已有的设计做以下修改：
1）符号表结构中，为参数特地加一个是否为引用的域isref_
2）四元式结构中，取址方式增加一种引用参数的取址方式REFERENCE_ADDRESSING，操作码由SETP变为SETP和SETREFP，ETP与SETREFP的生成过程的逻辑判断也要做相应更改
3）目标代码生成阶段中，实际取址的过程，增加引用取址的判断
在目标代码实现过程中，才明白了LEA操作的重要性。理论上，用MOV操作也可方便地加载地址，只要将第二个操作数变为表示地址的表达式即可。但用LEA时，可使第二个操作数与MOV，ADD,SUB,IMUL,IDIV等常用的操作码对应的操作数的格式保持一致。

备注：当过程/函数要求引用传参，而实参并不是左值时，该语义错误只有在中间代码生成时才可检测到。
即，该编译器对左/右值的处理，是在中间代码生成过程中进行判断的。

23. 出错处理
词法分析中，出错后舍弃当前单词，读取下一个单词；
语法分析中，出错后读完整条语句，直到读到分号或EOF，然后返回上一层分析函数；
语义分析中，出错后，重定义、外层的CONTINUE和BREAK时，继续分析。未定义时，读完整句读到分号或EOF后，返回上一层分析函数；
中间代码生成中，只有右值的引用传参会导致错误，


语义分析中，出错后，仍然应该正常读取所有的语法成分，但不产生动作。而不能一直读到分号再去处理。否则会破坏正常的语法分析层次。

24. 条件语句中，复合条件的处理
类似表达式，将复合条件分为：布尔表达式、布尔项与布尔因子，逐级处理。
该文法的问题在于，在布尔因子中，需要读入表达式(Expression)，或者由括号括起来的布尔表达式(BoolExpression)。当布尔因子的第一个单词是左括号时，无法区分到底该进行哪个分支。
故在语法分析时写出几个测试函数，遇到左括号时，先测试是否为算术表达式。如果是，就按照算术表达式来分析；否则按照布尔表达式来分析。
在语义分析和中间代码生成时，测试函数可以照搬语法分析的测试函数，因为单从语法结构上就可判定是算术表达式还是布尔表达式。
语义分析中，布尔表达式、布尔项与布尔因子，由于不需要处理标识符和符号表，故这三个函数和语法分析中的也是一样的。

在语义动作中，以if then @Label<beginthen> statement1 @JMP<end> @Label<endthen> else statement2 @Label<end>为例
布尔表达式、布尔项、布尔因子，均有两个参数：积极标志与消极标识，分别表示其正确时要跳转至的地址，与错误时要跳转至的地址。
布尔表达式的积极标志为Label_beginthen，消极标志为Label_endthen
布尔表达式与布尔项公用一个积极标志，每个布尔项后设置一个自己的消极标志
布尔项与布尔因子公用一个消极标志，每个布尔因子后设置一个自己的积极标志

对布尔表达式来说，在最后添加一个向消极标志的无条件跳转语句。将向积极标志的跳转工作交由布尔项完成，此时便可实现短路求值
对布尔项来说，在最后添加一个向积极标志的无条件跳转语句。将向消极标志的跳转工作交由布尔因子完成，此时便可实现短路求值
对布尔因子来说，若其为简单条件，则设置条件跳转语句，其跳转动作与条件的语义相反，跳转目的为消极标志。
若其为布尔表达式，则将积极标志与消极标志传入布尔表达式的解析过程。

在中间代码生成的过程，对标识的设置，与跳转语句进行优化，优化的情况为：
1) 单条件优化：
    取消不必要的Label
	1. 当BoolFactor中只是一个简单的条件判断，而非复杂的布尔表达式时，可在BoolTerm中分析完该BoolFactor后，取消一个Label的设置（该Label专门为当BooLFactor为布尔表达式时设定）；
	2. 当BoolTerm中只有一个Factor，且Factor为简单条件时，可在BoolExpression中取消一个Label的设置（该Label专门为当BooLTerm中有多个BoolFactor，或仅有一个BoolFactor但其为布尔表达式时设定）；
    取消不必要的跳转语句
	3. 当BoolTerm中只有一个Factor，且Factor为简单条件时，可在BoolTerm中取消最后一个向积极标识跳转的语句，并更改BoolFactor中唯一一个跳转语句，将其由“否定则跳转至消极标志”改为“肯定则跳转至积极标志”
	4. 当BoolExpression中只有一个简单的BoolTerm（即BoolTerm中只有一个简单条件）时，可取消BoolExpression中最后一个向消极标识跳转的语句，并更改BoolTerm中唯一一个跳转语句，将其由“肯定则跳转至积极标志”改为“否定则跳转至消极标志”	
2) 最右子元素优化：
	1. 因为BoolTerm中最后一个BoolFactor可能有(当其为布尔表达式时)跳转至该BoolFactor的label_positive的跳转语句，然而最后一个BoolFactor的label_positive之后紧跟着的就是JMP语句，跳转到该BoolTerm的label_positive。故将最后一个BoolFactor中的跳转至BoolFactor的label_positive的跳转语句的跳转地址改为BoolTerm的label_positive，即之后紧跟着的JMP语句的跳转地址
	2. 因为BoolExpression中最后一个BoolTerm可能有(当其为布尔表达式时)跳转至该BoolTerm的label_negative的跳转语句，然而最后一个BoolTerm的label_negative之后紧跟着的就是JMP语句，跳转到该BoolExpression的label_negative。故将最后一个BoolTerm中的跳转至BoolTerm的label_negative的跳转语句的跳转地址改为BoolExpression的label_negative，即之后紧跟着的JMP语句的跳转地址
4) 跨层次优化：
	1. IfStatement和WhileStatement中，打下label_beginthen的前一句可能就是BoolExpression中的JMP<label_positive>语句，故可去掉JMP语句。
	2. 每一个JMP语句，若其下一个语句是Label，且前一个语句是条件跳转，且条件跳转的目的是JMP语句的下一个语句的Label标志，则可去掉该JMP语句，并且将前一个条件跳转语句取反，跳至原JMP语句要跳转的位置。
	   一个典型的例子就是，当处理if(1 < 2 || 3 < 4)时，对3<4的跳转的优化
	3. if和while条件分析完成后，对每一个Label语句（除了while的checklabel），判断其是否被作为目的地址使用过，若未曾使用，则取消该Label语句
至此，完成所有优化
