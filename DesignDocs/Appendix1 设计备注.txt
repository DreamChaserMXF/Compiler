1. 对常量的处理：
在C++中，实际存在两种常量，一种是编译时就可确定其值的，往往是用常量表达式初始化的const修饰的变量。
另一种常量是也用const修饰，但却用非常量表达式初始化的变量，这样的常量属于常变量。

在PL/0语言中，定义的常量均属于第一种常量。
故程序在处理时，在四元式生成过程中，就将常量替换成为常数，而不用特定的常变量来对其进行特别的分类处理。
因此，常量继续占据存储空间也没什么意义了，所以在符号表中，令所有的常量的地址为零，不占据存储空间。

2. 由于对常量的处理方式，故case语句可将情况表元素扩展为常数与常量。但暂不准备扩展为常量表达式。

3. 扩展continue和break
在语法分析时，时刻维护着一个continue和break的跳转标号栈
遇到continue或break时，就跳到栈顶
若栈为空，说明无法跳转，报错

4. 赋值优化
赋值语句中，若被赋值元素非数组，且赋值号右边的表达式的属性是临时变量，则可以优化掉赋值语句的四元式，直接将被赋值元素的属性写到表达式中最后一条语句的dst中即可

/*但有一项情况特殊，因为NEG的四元式的效果最初是这样设计的：dst[offset] = -dst[offset]，这样，当dst是临时变量时，如果NEG被赋值语句优化掉，那么NEG的语义中的源操作数也将失效。
有两种选择：第一种是更改NEG的语义为 dst = - src1，此时将源操作数与目的操作数分开，便不会影响赋值语句的优化。
第二种选择，是在赋值语句处判定，如果上一条语句是NEG，便不予优化。

首先考虑的一点：如果用第一种选择，便丢失了数组操作数。那么，可以验证一下，在汇编语言中，NEG的操作数可否为内存地址。如果可以的话，第一种选择确实是一种损失。因为对数组元素的取反，本来一条NEG的汇编指令就可完成，现在需要将数组元素赋值给临时变量，再取反，再赋值回自己。
第二种选择问题在于，这样的NEG的语义形式与其他四元式的就不统一了，不知道在做编译优化的时候是否会有影响。

验证NEG的操作数：可以为内存地址。
故暂采用第二种方法，在赋值语句优化处进行判定，对NEG进行特殊处理。
若到了编译优化时，发现NEG语句的语义不统一造成了更大的问题，再作斟酌。
*/

卧槽，NEG的语义写错了，还没遇到赋值号，怎么能产生副作用呢？！
重写NEG四元式！


5. 类型转换
设计了VOID CHAR INTEGER的类型转换规则与类型转换矩阵

6. 汇编中的call和ret
如果自己用jmp语句代替call和ret的话，会对运行栈有较好的理解
如果使用汇编中的call和ret的话，编写汇编过程会方便些
由于汇编指令中不允许操作EIP寄存器，故只能用call和ret实现函数的调用和返回【注：函数调用可以用jmp代替，但无法存储返回地址】

7. 函数返回值的存储
在正常处理流程中，希望将函数的返回值放置在temp#tempvar_index的位置，这样比较贴合之前的设计框架。否则还要有专门处理函数返回值的操作数属性（因其取址方式比较特殊）
但在子函数中，无法判定temp#tempvar_index的位置。如果放在活动记录块的起始位置的话，这块内存在调用者的栈中的相对位置是不确定的，需要由ESP的具体控制方式来决定，而且无论ESP如何控制，在实现的时候都很麻烦，要处理特殊情况，在设计时与运行栈的结构紧密相关。
所以子函数将返回值存储在EAX中，再加一条指令，将EAX的值存进临时变量中。
注：存储EAX至临时变量的语句，可能会被赋值语句优化掉，直接存储至普通变量中。

8. 运行栈中栈指针ESP的控制
运行栈中，局部变量的数量是固定的，这里不会变动。但由于临时变量有申请，有释放，所以实际的栈顶是会变的。
但如果每次都随着临时变量的申请和释放来调整栈顶指针的话，又太过麻烦，效率太低。
所以，在生成中间代码时，记录好每个过程/函数中用到的临时变量的数量，在初始化活动记录块时，用SP预留出足够的空间来，就不需要变来变去了。

9. 临时变量使用的最大数量计算
在中间代码生成时，手动为主函数生成BEGIN和END
然后扫描一遍中间代码，对每个BEGIN语句所代表的函数，找到最大的临时变量使用数，更新到BEGIN语句中

10. 过程调用与函数调用
在最后的实现中，两者的调用方式都是相同的。这是因为将函数的返回值的存储位置定为了EAX中。
如果将返回值放在运行栈中的话，那么函数调用就要比过程调用多预留出一个返回值的存储位置。
但由于最开始的设定中，两者的调用方式不同，故出现了两种四元式的操作码，FUNC_CALL与PROC_CALL。
在最后的实现中，两者翻译成的汇编码是相同的。

11. write函数调用时的类型推导
在实现时，困难之处在于，编译到中间代码四元式时，四元式的信息中，只有一个操作符和三个操作数。操作数有两个属性，取址方式属性和值属性。但却没有类型属性。
在最终转换成汇编码的时候，是通过四元式和符号表来转换的。而如果四元式的操作数是立即数或临时变量，那么，它们的类型是什么呢？
没错，是可以在四元式中的取址方式中，将立即数改成整型立即数和字符型立即数，将临时变量也赋予类型，甚至将临时变量存储在符号表中。但这样子，就破坏了取址方式本来的意义，造成了划分的不统一（本来是每种取址方式对应一个枚举类型，但现在一种立即数的取址方式就对应了两个枚举类型）。
所以，为了照顾write的类型推断，这里就只好把四元式的目的操作数再加一个类型属性了。

12. EBP的位置设定
在最开始时，本来想将EBP设置在display区的开始位置，即[EBP-4]为display区的第一个元素。
但这样的话，在函数调用之前，就要设置EBP。但调用前要赋值display区和参数，也要用到EBP。所以只能在display区处理完成、参数压栈滞后，call语句之前设置EBP。
但此时需要保存EBP的值，在函数调用完成后再自行恢复。因为有函数参数在栈中，故不能用栈的PUSH POP来保存EBP。否则就要修改运行栈的结构。
且在翻译到call语句时，EBP的位置设定还需计算。
故采用通用的方法，在被调用的函数的首部将EBP压栈并设置EBP，返回时将EBP出栈即可。这样，调用者不必考虑EBP的改变，在call完之后，只需修改栈顶指针，便可恢复现场。

13. 临时变量的编号方式
之前的临时变量的编号都是从0开始，这样会给寻址带来很大不便。
本想更改为，临时变量与局部变量统一编址。在subroutine中的变量说明部分完成后，便可确定临时变量的个数。
然而，这样会导致之后很难准确计算一个函数中使用的临时变量个数。
但如果统一编址的话，就不需要单独计算临时变量个数了，而需计算局部变量和临时变量的总数【因为计算临时变量的个数是用来调整栈顶指针的，而栈顶指针的调整需要局部变量和临时变量所占的空间之和】
但计算局部变量和临时变量的总数的话，太麻烦了。
所以还是令临时变量的编号从0开始好了。

另：普通变量和临时变量在寻址时确实方式有差异（普通变量可能是外层变量，临时变量只会是局部变量）

14. 四元式生成时，对两个常数的运算的优化->直接在编译时计算结果

15. 符号表中的层次问题
符号表中，隐含的主函数是第0层，主函数中定义的变量和过程/函数是第1层。
这样，函数的层次便可和display区的长度统一起来。
在符号表生成时，level的初值是1。因为主函数名不出现在符号表中，所以level的初值不需要为0。