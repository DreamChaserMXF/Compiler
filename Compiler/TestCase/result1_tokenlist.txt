TokenNumber	LineNumber	TokenType	    TokenValue
1		1		CONST               const
2		1		IDENTIFIER          ARRLEN
3		1		EQU                 =
4		1		CONST_INTEGER       100
5		1		COMMA               ,
6		1		IDENTIFIER          NEGATIVE
7		1		EQU                 =
8		1		CONST_INTEGER       -1
9		1		COMMA               ,
10		1		IDENTIFIER          TRUE
11		1		EQU                 =
12		1		CONST_INTEGER       1
13		1		COMMA               ,
14		1		IDENTIFIER          FALSE
15		1		EQU                 =
16		1		CONST_INTEGER       0
17		1		COMMA               ,
18		1		IDENTIFIER          ENDCHAR
19		1		EQU                 =
20		1		CONST_CHAR          a
21		1		SEMICOLON           ;
22		3		VAR                 var
23		3		IDENTIFIER          i
24		3		COMMA               ,
25		3		IDENTIFIER          j
26		3		COMMA               ,
27		3		IDENTIFIER          k
28		3		COLON               :
29		3		RW_INTEGER          integer
30		3		SEMICOLON           ;
31		4		IDENTIFIER          lastChar
32		4		COLON               :
33		4		RW_CHAR             char
34		4		SEMICOLON           ;
35		5		IDENTIFIER          sum
36		5		COLON               :
37		5		RW_INTEGER          integer
38		5		SEMICOLON           ;
39		6		IDENTIFIER          sequence
40		6		COLON               :
41		6		ARRAY               array
42		6		LEFT_BRACKET        [
43		6		CONST_INTEGER       100
44		6		RIGHT_BRACKET       ]
45		6		OF                  of
46		6		RW_INTEGER          integer
47		6		SEMICOLON           ;
48		8		BEGIN               begin
49		9		IDENTIFIER          sequence
50		9		LEFT_BRACKET        [
51		9		CONST_INTEGER       0
52		9		RIGHT_BRACKET       ]
53		9		ASSIGN              :=
54		9		CONST_INTEGER       1
55		9		SEMICOLON           ;
56		10		IDENTIFIER          sequence
57		10		LEFT_BRACKET        [
58		10		CONST_INTEGER       1
59		10		RIGHT_BRACKET       ]
60		10		ASSIGN              :=
61		10		CONST_INTEGER       2
62		10		SEMICOLON           ;
63		11		IDENTIFIER          sequence
64		11		LEFT_BRACKET        [
65		11		CONST_INTEGER       2
66		11		RIGHT_BRACKET       ]
67		11		ASSIGN              :=
68		11		CONST_INTEGER       3
69		11		SEMICOLON           ;
70		12		IDENTIFIER          sequence
71		12		LEFT_BRACKET        [
72		12		CONST_INTEGER       3
73		12		RIGHT_BRACKET       ]
74		12		ASSIGN              :=
75		12		CONST_INTEGER       4
76		12		SEMICOLON           ;
77		13		IDENTIFIER          sequence
78		13		LEFT_BRACKET        [
79		13		CONST_INTEGER       4
80		13		RIGHT_BRACKET       ]
81		13		ASSIGN              :=
82		13		CONST_INTEGER       5
83		13		SEMICOLON           ;
84		14		IDENTIFIER          sequence
85		14		LEFT_BRACKET        [
86		14		CONST_INTEGER       5
87		14		RIGHT_BRACKET       ]
88		14		ASSIGN              :=
89		14		CONST_INTEGER       6
90		14		SEMICOLON           ;
91		16		FOR                 for
92		16		IDENTIFIER          i
93		16		ASSIGN              :=
94		16		CONST_INTEGER       0
95		16		TO                  to
96		16		CONST_INTEGER       5
97		16		DO                  do
98		17		BEGIN               begin
99		18		IF                  if
100		18		IDENTIFIER          i
101		18		LT                  <
102		18		CONST_INTEGER       3
103		19		THEN                then
104		19		WRITE               write
105		19		LEFT_PAREN          (
106		19		CONST_STRING        
i < 3 
107		19		COMMA               ,
108		19		IDENTIFIER          i
109		19		RIGHT_PAREN         )
110		20		ELSE                else
111		20		WRITE               write
112		20		LEFT_PAREN          (
113		20		CONST_STRING        
i >= 3 
114		20		COMMA               ,
115		20		IDENTIFIER          i
116		20		RIGHT_PAREN         )
117		21		END                 end
118		21		SEMICOLON           ;
119		23		FOR                 for
120		23		IDENTIFIER          i
121		23		ASSIGN              :=
122		23		CONST_INTEGER       0
123		23		TO                  to
124		23		CONST_INTEGER       5
125		23		DO                  do
126		24		BEGIN               begin
127		25		IF                  if
128		25		IDENTIFIER          i
129		25		GT                  >
130		25		CONST_INTEGER       5
131		26		THEN                then
132		26		WRITE               write
133		26		LEFT_PAREN          (
134		26		CONST_STRING        
i > 5 
135		26		COMMA               ,
136		26		IDENTIFIER          i
137		26		RIGHT_PAREN         )
138		27		ELSE                else
139		27		IF                  if
140		27		IDENTIFIER          i
141		27		GT                  >
142		27		CONST_INTEGER       3
143		28		THEN                then
144		28		WRITE               write
145		28		LEFT_PAREN          (
146		28		CONST_STRING        
3 < i <= 5 
147		28		COMMA               ,
148		28		IDENTIFIER          i
149		28		RIGHT_PAREN         )
150		29		ELSE                else
151		29		IF                  if
152		29		IDENTIFIER          i
153		29		LT                  <
154		29		CONST_INTEGER       1
155		30		THEN                then
156		30		WRITE               write
157		30		LEFT_PAREN          (
158		30		CONST_STRING        
i < 1 
159		30		COMMA               ,
160		30		IDENTIFIER          i
161		30		RIGHT_PAREN         )
162		31		ELSE                else
163		31		WRITE               write
164		31		LEFT_PAREN          (
165		31		CONST_STRING        
1 <= i <= 3 
166		31		COMMA               ,
167		31		IDENTIFIER          i
168		31		RIGHT_PAREN         )
169		32		END                 end
170		32		SEMICOLON           ;
171		34		FOR                 for
172		34		IDENTIFIER          i
173		34		ASSIGN              :=
174		34		CONST_INTEGER       0
175		34		TO                  to
176		34		CONST_INTEGER       5
177		34		DO                  do
178		35		BEGIN               begin
179		36		IF                  if
180		36		IDENTIFIER          sequence
181		36		LEFT_BRACKET        [
182		36		IDENTIFIER          i
183		36		RIGHT_BRACKET       ]
184		36		GT                  >
185		36		CONST_INTEGER       5
186		37		THEN                then
187		37		WRITE               write
188		37		LEFT_PAREN          (
189		37		CONST_STRING        
sequence[i] > 5 
190		37		COMMA               ,
191		37		IDENTIFIER          sequence
192		37		LEFT_BRACKET        [
193		37		IDENTIFIER          i
194		37		RIGHT_BRACKET       ]
195		37		RIGHT_PAREN         )
196		38		ELSE                else
197		38		IF                  if
198		38		IDENTIFIER          sequence
199		38		LEFT_BRACKET        [
200		38		IDENTIFIER          i
201		38		RIGHT_BRACKET       ]
202		38		GT                  >
203		38		CONST_INTEGER       3
204		39		THEN                then
205		39		WRITE               write
206		39		LEFT_PAREN          (
207		39		CONST_STRING        
3 < sequence[i] <= 5 
208		39		COMMA               ,
209		39		IDENTIFIER          sequence
210		39		LEFT_BRACKET        [
211		39		IDENTIFIER          i
212		39		RIGHT_BRACKET       ]
213		39		RIGHT_PAREN         )
214		40		ELSE                else
215		40		IF                  if
216		40		IDENTIFIER          sequence
217		40		LEFT_BRACKET        [
218		40		IDENTIFIER          i
219		40		RIGHT_BRACKET       ]
220		40		LT                  <
221		40		CONST_INTEGER       1
222		41		THEN                then
223		41		WRITE               write
224		41		LEFT_PAREN          (
225		41		CONST_STRING        
sequence[i] < 1 
226		41		COMMA               ,
227		41		IDENTIFIER          sequence
228		41		LEFT_BRACKET        [
229		41		IDENTIFIER          i
230		41		RIGHT_BRACKET       ]
231		41		RIGHT_PAREN         )
232		42		ELSE                else
233		42		WRITE               write
234		42		LEFT_PAREN          (
235		42		CONST_STRING        
1 <= sequence[i] <= 3 
236		42		COMMA               ,
237		42		IDENTIFIER          sequence
238		42		LEFT_BRACKET        [
239		42		IDENTIFIER          i
240		42		RIGHT_BRACKET       ]
241		42		RIGHT_PAREN         )
242		43		END                 end
243		43		SEMICOLON           ;
244		44		WRITE               write
245		44		LEFT_PAREN          (
246		44		CONST_STRING        

247		44		RIGHT_PAREN         )
248		44		SEMICOLON           ;
249		46		CASE                case
250		46		IDENTIFIER          i
251		46		OF                  of
252		46		CONST_INTEGER       0
253		47		COLON               :
254		47		WRITE               write
255		47		LEFT_PAREN          (
256		47		CONST_STRING        i = 0
257		47		RIGHT_PAREN         )
258		47		SEMICOLON           ;
259		47		CONST_INTEGER       1
260		48		COLON               :
261		48		WRITE               write
262		48		LEFT_PAREN          (
263		48		CONST_STRING        i = 1
264		48		RIGHT_PAREN         )
265		48		SEMICOLON           ;
266		48		CONST_INTEGER       2
267		49		COLON               :
268		49		WRITE               write
269		49		LEFT_PAREN          (
270		49		CONST_STRING        i = 2
271		49		RIGHT_PAREN         )
272		49		SEMICOLON           ;
273		49		CONST_INTEGER       3
274		50		COLON               :
275		50		WRITE               write
276		50		LEFT_PAREN          (
277		50		CONST_STRING        i = 3
278		50		RIGHT_PAREN         )
279		50		SEMICOLON           ;
280		50		CONST_INTEGER       4
281		51		COLON               :
282		51		WRITE               write
283		51		LEFT_PAREN          (
284		51		CONST_STRING        i = 4
285		51		RIGHT_PAREN         )
286		51		SEMICOLON           ;
287		51		CONST_INTEGER       5
288		52		COLON               :
289		52		WRITE               write
290		52		LEFT_PAREN          (
291		52		CONST_STRING        i = 5
292		52		RIGHT_PAREN         )
293		52		SEMICOLON           ;
294		52		CONST_INTEGER       6
295		53		COLON               :
296		53		WRITE               write
297		53		LEFT_PAREN          (
298		53		CONST_STRING        i = 6
299		53		RIGHT_PAREN         )
300		54		END                 end
301		54		SEMICOLON           ;
302		55		WRITE               write
303		55		LEFT_PAREN          (
304		55		CONST_STRING        

305		55		RIGHT_PAREN         )
306		55		SEMICOLON           ;
307		56		END                 end
308		56		PERIOD              .
